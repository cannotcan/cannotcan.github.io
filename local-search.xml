<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>RSA简介</title>
    <link href="/2022/11/12/RSA%E7%AE%80%E4%BB%8B/"/>
    <url>/2022/11/12/RSA%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<p>表征相似性分析是怎么回事呢？表征相信大家都很熟悉，但是相似性分析是怎么回事呢？下面就让小编带大家一起了解吧。 </p><p>表征相似性分析，其实就是相似性分析了。那么为什么会对表征做相似性分析，相信大家都很好奇是怎么回事。大家可能会感到很惊讶，怎么会对表征做相似性分析呢？但事实就是这样，小编也感到非常惊讶。那么这就是关于表征相似性分析的事情了，大家有没有觉得很神奇呢？</p><p>看了今天的内容，大家有什么想法呢？欢迎在评论区告诉小编一起讨论哦。</p><p>好了不发疯了hhh，下面认真讲讲表征相似性分析(representational similarity analysis，RSA)是个啥。</p><blockquote><p>提前说明，本文就只是基于我对RSA的一些浅显了解来写的，主要目的也是说给大家介绍一下这个东西，以后文献里看到了不至于那么蒙。</p></blockquote><p>目前打算这篇文章（或者系列？）会分成一下几个部分来介绍：</p><ol><li>对RSA概念的整体感受（top-down）</li><li>具体到神经影像学-行为学的研究，RSA是什么</li><li>怎么做一个RSA</li><li>手把手完成一个RSA（也许会单独出个文章吧）</li><li>RSA的一些考虑？（也许会写吧，不过也可能会显得太trivial了）</li></ol><h2 id="对RSA概念的整体感受"><a href="#对RSA概念的整体感受" class="headerlink" title="对RSA概念的整体感受"></a>对RSA概念的整体感受</h2><p>在正式讲RSA是怎么在神经影像领域里大显身手之前，我想大家聊聊我对RSA的一些可能偏抽象的理解，也许能帮助到一些同学更好地接受这个概念。<br>像<code>小编</code>说的一样，我们把RSA分成<code>表征</code>和<code>相似性分析</code>。<br>我看到这个名字的第一感受是</p><blockquote><p>什么是表征？</p><p>为什么不直接研究表征，要去选一条曲折的路，转而研究表征的相似性？</p></blockquote><p><code>表征</code></p><blockquote><p>表征，是信息在头脑中的呈现方式</p></blockquote><p><code>representation</code></p><blockquote><p>representation</p></blockquote><p><code>表征</code>的中文释义从百度百科上摘过来，就带着一些心理学的味道，说<code>表征是信息在头脑中的呈现方式</code>。</p><p>我们可以结合英文对<code>representation</code>的解释思考一下，这个释义，最核心的内容应该是在于信息从一个<code>模态</code>（modality），经过一定的<code>变换</code>之后，转换到了另一<code>模态</code>下，这一转换的结果，或者说转换的过程，就叫做表征。</p><p>例如，一个苹果，好端端地呆在一个地方，你路过它，“啪”得一下拿出手机给它拍了张照，从你那个角度能够观察到的苹果在现实世界里的那些光的信息就转换成了你手机里面存储的一个数字格式“冷冰冰”的01010001…了。<br>而一串的01010001…，就是你的手机对这个苹果的一些信息的<code>表征</code>。<br>这是个物理世界中的例子，大家可以看到，我们把<code>苹果</code>、<code>照相</code>和<code>01010001...</code>和上面的<code>第一个模态的信息</code> $\rightarrow$ <code>变换</code> $\rightarrow$ <code>第二个模态的信息</code>是可以一一对应起来的。<br>并且大家需要注意到的是，在这个例子里面，这三个重要组成元素我们是能做到直接检验的，特别是后面的<code>照相</code>和<code>01010001...</code>。当然这个是当然的，毕竟照相机是人类发明的，人们在发明之前肯定是对光的一些原理是有了足够的了解的；同样这串编码<code>01010001...</code>，或者照片的存储格式也是人类规定的，也是可以直接读取的。那么我们当然是可以对<code>表征</code>进行直接的探究。</p><p>此外，大家需要注意到的一点是，这个概念，和这个例子隐含了的假设是什么。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 第二个模态中的信息都是由第一个模态里的信息经过变换而来的<br><span class="hljs-bullet">2.</span> 不同的信息在确定的变换程序下不会产生相同的表征<br></code></pre></td></tr></table></figure></p><p>这是个啥？<br>这是个双射的函数关系呀，同志们！</p><p>也就是说再抽象一点，表征就是在原始空间$X$到目标空间$Y$之间定义了一个变换$\Phi$，同时这个变换能够满足</p><script type="math/tex; mode=display">Y = \Phi(X) \\\forall x\neq y\in X, \Phi(x)\neq\Phi(y)\\</script><p>这个就是作者认为的，表征是一种一阶同构(homomorphism)，其实也就是函数里的双射，一一对应的关系。</p><p>现在我们转回之前说的第二个问题</p><blockquote><p>为什么不直接对表征进行研究呢？</p></blockquote><p>很简单的回答就是</p><p>我不知道！</p><p>hhh开个玩笑，实际上就是在心理学的研究里面我们既不知道$\Phi$，就算是$y$（或者说$\Phi(x)$），也不能说完全掌握它的信息，只是有各种各样的测量手段/工具去测量它，可能获得某一个剖面的信息。</p><p>大家都知道，普心上写心理学的基本任务是描述、解释、预测和控制。<br>我们做研究的很大一个目的就是要去探讨不同心理过程之间、心理过程与行为之间的联系，以及他们的内部机制是什么，是怎么联系在一起的。所以对$\Phi$的“无知”是正常的。<br>对于 $y$ 呢，我们都知道心理学是建立在各式各样的量表、繁多的实验范式上的，当然还要加上神经影像的数据。这些测量手段，假设都是对同一个 $y$ 测量，提供了丰富但也片面的信息，那么怎么根据这些丰富的测量信息，去反推$\Phi$就是我们的主要目标。</p><p>还是用上面那个<code>苹果</code>、<code>照相</code>和<code>01010001...</code>的例子。假设我们现在有两个完全相同的手机，一个的相机打开了美食模式————即，它拍出来的苹果会看起来好吃一点之类的，另一个手机就是原相机模式。<br>我们用这两个手机在同一时间同一位置给同一个苹果拍照，然后分别得到了两张照片 $P_1$ 和 $P_2$。然后假设我们想要分辨这两个其他特征完全一致的手机，哪一台是开了美食模式的，哪一台是原相机模式，我们可以怎么做呢。</p><p>假设$\Phi$和$\varPhi’$分别是原相机和开了美食滤镜下的变换<br>我们先来确认一下我们已有的条件有哪些</p><ul><li>原信息苹果 $x$ 是不变的 </li><li>$P_1$ 和 $P_2$ 我们也是掌握了的</li><li>此外，因为 $\Phi$ 和 $\varPhi’$ 都是人类工程师开发出来的，我们也完全知道这两个变换</li></ul><p>那么解决这个问题我们就有<code>forward</code>和<code>backward</code>这两种方法。</p><p><code>forward</code>方法下，我们就简单地把$x$分别放到 $\Phi$ 和 $\varPhi’$ 里面，看 $P_1$ 和 $P_2$ 分别和 $\Phi(x)$ 和 $\varPhi’(x)$哪个更接近就行了</p><p>那么<code>backward</code>方法下呢，因为 $\Phi$ 和 $\varPhi’$ 都是同构嘛，我们也可以简单地给$P_1$ 和 $P_2$ 取个逆就好。比如$P_1$，我们就看 $\Phi^{-1}(P_1)$ 和 $\varPhi’^{-1}(P_1)$ 哪个能够得到 $x$ 就好。</p><p>那么现在我们慢慢把给出的条件一个一个拿掉，试一下是否还能有足够的信息把这个问题解出来。<br>如果不够，添加哪些更弱的条件才可以。</p><h3 id="1-我们不知道-Phi-或者-varPhi’-的具体形式"><a href="#1-我们不知道-Phi-或者-varPhi’-的具体形式" class="headerlink" title="1. 我们不知道 $\Phi$ 或者 $\varPhi’$ 的具体形式"></a>1. 我们不知道 $\Phi$ 或者 $\varPhi’$ 的具体形式</h3><p>这个条件在心理学是很常见的，毕竟我们的首要目标就是把 $\Phi$ 解出来，要是知道的话我们也就不用忙活了。<br>我们可以看到，因为前面提到的<code>forward</code>或者<code>backward</code>方法都直接用到了 $\Phi$ 和 $\varPhi’$ ，此刻就都歇菜了，直接照着用肯定不行了</p><p>那在心理学领域，我给一个脑子看了一个苹果</p>]]></content>
    
    
    <categories>
      
      <category>知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据分析</tag>
      
      <tag>心理学</tag>
      
      <tag>神经影像</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo使用</title>
    <link href="/2021/07/05/manual-hexo/"/>
    <url>/2021/07/05/manual-hexo/</url>
    
    <content type="html"><![CDATA[<p>记录一下hexo常用的一些命令</p><span id="more"></span><h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">hexo new [layout]&lt;<span class="hljs-built_in">title</span>&gt;<br></code></pre></td></tr></table></figure><p>新建一篇文章，如果没有指定<code>layout</code>的话，会默认使用_config.yml中的<code>default_layout</code>。直接写标题名字就好了，会自动生成一个以此为标题的md文件，如果有空格的话需要用引号括起来。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">hexo <span class="hljs-keyword">new</span> <span class="hljs-string">&quot;manual_hexo&quot;</span><br></code></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-p</code>, <code>--path</code></td><td>自定义新文章的路径</td></tr><tr><td><code>r</code>, <code>--replace</code></td><td>如果存在同名文章，将其替换</td></tr><tr><td><code>-s</code>, <code>--slug</code></td><td>文章的Slug，作为新文章的文件名和发布后的URL</td></tr></tbody></table></div><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">hexo <span class="hljs-keyword">new</span> <span class="hljs-type">page</span> --path about/me <span class="hljs-string">&quot;About me&quot;</span><br></code></pre></td></tr></table></figure><h2 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h2><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs verilog">hexo <span class="hljs-keyword">generate</span><br>简写为<br>hexo g<br></code></pre></td></tr></table></figure><p>生成静态文件</p><div class="table-container"><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td><code>-d</code>, <code>--deply</code></td><td>文件生成后立即部署网站</td></tr><tr><td><code>-w</code>, <code>--watch</code></td><td>监视文件变动</td></tr><tr><td><code>-b</code>, <code>--bail</code></td><td>生成过程中如果发生任何未处理的异常则抛出异常</td></tr><tr><td><code>-f</code>, <code>--force</code></td><td>强制重新生成文件。如果该参数的效果接近hexo clean &amp;&amp; hexo generate</td></tr><tr><td><code>-c</code>, <code>--concurrency</code></td><td>最大同时生成文件的数量，默认无限制</td></tr></tbody></table></div><h2 id="publish"><a href="#publish" class="headerlink" title="publish"></a>publish</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">hexo publish [layout]<span class="hljs-tag">&lt;<span class="hljs-name">filename</span>&gt;</span><br></code></pre></td></tr></table></figure><p>发表草稿</p><h2 id="server"><a href="#server" class="headerlink" title="server"></a>server</h2><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">hexo <span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><p>启动服务器。默认情况下，访问网址为：<code>http://localhost:4000</code></p><h2 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h2><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">hexo <span class="hljs-keyword">deploy</span><br>简写为<br>hexo d<br></code></pre></td></tr></table></figure><p>部署网站。</p><div class="table-container"><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-g</code>, <code>--generate</code></td><td>部署之前预先生成静态文件</td></tr></tbody></table></div>]]></content>
    
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TrimTest</title>
    <link href="/2021/07/05/TrimTest/"/>
    <url>/2021/07/05/TrimTest/</url>
    
    <content type="html"><![CDATA[<p>记录一下怎么用递归实现java中String类的trim方法</p><p>以及做这个题的遇到一个问题</p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringInterviewTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String s1 = <span class="hljs-string">&quot;   h e  &quot;</span>;<br>        String s1_trimed = trimTest(s1);<br><br>        System.out.println(s1);<br>        System.out.println(s1_trimed);<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">trimTest</span><span class="hljs-params">(String str)</span> </span>&#123;<br>        <span class="hljs-comment">// 模拟String自带的trim方法去除string首尾的空格</span><br><br>        <span class="hljs-keyword">if</span> ((str.charAt(<span class="hljs-number">0</span>) != <span class="hljs-string">&#x27; &#x27;</span> &amp;&amp; str.charAt(str.length()-<span class="hljs-number">1</span>) != <span class="hljs-string">&#x27; &#x27;</span>) || str.isEmpty() || str.isBlank()) &#123;<br>            <span class="hljs-keyword">return</span> str;<br>        &#125;<br>        str = (str.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27; &#x27;</span>) ? str.substring(<span class="hljs-number">1</span>) : str;<br>        str = (str.charAt(str.length()-<span class="hljs-number">1</span>) == <span class="hljs-string">&#x27; &#x27;</span>) ? str.substring(<span class="hljs-number">0</span>, str.length()-<span class="hljs-number">1</span>) : str;<br>        str = trimTest(str);<br>        <span class="hljs-keyword">return</span> str;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>重点在于倒数第4行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">str = trimTest(str);<br><span class="hljs-comment">// trimTest(str);</span><br></code></pre></td></tr></table></figure><p>本来写的是注释里的内容，但是最后函数跑出来的结果是没有变的</p><p>想了想应该是因为java是值传递的，只使用trimTest(str)，改变了str的一个拷贝的值，然后递归一层一层的从出栈的时候结果就丢失掉了。</p><p>这也能解释为什么如果在前面加一句System.out.println(str)的话，能发现空格确实有在减少但是最后的结果却没有变化。</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Recursion</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性回归</title>
    <link href="/2021/04/09/GLM/"/>
    <url>/2021/04/09/GLM/</url>
    
    <content type="html"><![CDATA[<h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a><strong>Overview</strong></h3><p>线性回归，是心理学中最常用的一种数据分析模型，在<em>t</em>检验，方差分析（ANOVA）或是协方差分析（ANCOVA）中都有体现。</p><p>在最简单的单一因变量（dependent varible），单一自变量（independent variable/ regressor）的情况下 ，例如包含n个数据点的X和Y。线性回归的目的就是找到一组参数，能够使得模型能够最好地拟合我们的实际结果（不过感觉话说回来，感觉这是所有parametric analysis的目的），在这个例子中，我们如果假设X和Y之间的关系是</p><script type="math/tex; mode=display">Y = \beta_0+\beta_1X+\epsilon</script><p>其中$\epsilon\sim N(0, \sigma^2I)$</p><p>我们的目标也就是找到对应的$\beta_0$，$\beta_1$，让$\hat Y= \hat\beta_0+\hat\beta_1X$和$Y$的差异最小。</p><h3 id="简单线性回归"><a href="#简单线性回归" class="headerlink" title="简单线性回归"></a><strong>简单线性回归</strong></h3><p>在上述的例子中，描述的就是一个简单线性回归的问题，解这类问题通常使用的方法是最小二乘法，也就是尽可能的降低$Y和\hat Y$之间差异，即残差<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="残差：residual，为观测值和预测值之间的差异。要注意和误差(error)，之间的不同点，误差是观测值和真实值之间的差异——这是由于经典测量理论(CTT)的基本假设认为，真实值等于观测值加上误差。">[1]</span></a></sup>的平方。残差用e表示，那么$\rm e = Y - \hat Y $。而$\sigma^2$的估计值为$\rm\sigma^2 = \dfrac{e’e}{n-2}$，其中n也就是数据点的数量。n-2是模型的自由度——数据点的个数（n）减去需要估计的参数的数量（$\beta_0和\beta_1$）</p><h3 id="多变量线性回归"><a href="#多变量线性回归" class="headerlink" title="多变量线性回归"></a><strong>多变量线性回归</strong></h3><p>在一个模型中可以有多个自变量，$X_1,\;X_2,\;…,\;X_p$，也即是，</p><script type="math/tex; mode=display">Y = \beta_0+\beta_1X_1+\beta_2X_2+...+\beta_pX_p+\epsilon</script><p>其中$\beta_i$的意义为当控制其他的自变量不变时，$X_i$改变一单位后$Y$的变化大小。$\epsilon\sim N(0, \sigma^2I)$</p><p>如果使用矩阵的表示方法的话，那么X和Y之间的关系可以表示为：</p><script type="math/tex; mode=display">Y = \mathbf{X\beta}+\epsilon</script><p>$\mathbf X$是个$n\times (p+1)$的矩阵，$\beta$是$p+1$的列向量</p><p>对$\beta$的估计可以通过对正则方程（normal equation）的求解而得到。即</p><script type="math/tex; mode=display">X'X=X'X\beta</script><p>$\beta$的估计值为$\hat\beta =(X’X)^{-1}X’Y$，假设$X’X$是可逆的</p><p>$\sigma^2$的估计值$\hat\sigma^2=\dfrac{\rm e’e}{n-(p+1)}$</p><p>为了保证$X’X$的可逆性，$X$必须是满秩的，即$X$的每一列都不是其他列的线性组合。</p><h3 id="假设检验"><a href="#假设检验" class="headerlink" title="假设检验"></a><strong>假设检验</strong></h3><p>例如对于上述的模型来说，定义对照(contrast)的向量是一个长度为$p+1$的行向量。例如，假设有4个参数，$\beta_0,\;\beta_1,\;\beta_2,\;\beta_3$如果要检验的虚无假设为$H_0:\beta_1=0$，那么定义的对照c = [0 1 0 0]</p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>残差：residual，为观测值和预测值之间的差异。要注意和误差(error)，之间的不同点，误差是观测值和真实值之间的差异——这是由于经典测量理论(CTT)的基本假设认为，真实值等于观测值加上误差。<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据分析</tag>
      
      <tag>心理学</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
